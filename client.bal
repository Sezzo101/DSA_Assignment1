// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/url;
import ballerina/io;
 

public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(string serviceUrl, ConnectionConfig config =  {}) returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }
    # Get a list of all lecturers
    #
    # + return - List of lecturers 
    resource isolated function get lecturers() returns Lecturer[]|error {
        string resourcePath = string `/lecturers`;
        Lecturer[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Add a new lecturer
    #
    # + return - Created 
    resource isolated function post lecturers(Lecturer payload) returns Lecturer|error {
        string resourcePath = string `/lecturers`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Lecturer response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get details of a specific lecturer by staff number
    #
    # + return - Lecturer details 
    resource isolated function get lecturers/[string staffNumber]() returns Lecturer|error {
        string resourcePath = string `/lecturers/${getEncodedUri(staffNumber)}`;
        Lecturer response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update an existing lecturer's information
    #
    # + return - Updated 
    resource isolated function put lecturers/[string staffNumber](Lecturer payload) returns Lecturer|error {
        string resourcePath = string `/lecturers/${getEncodedUri(staffNumber)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Lecturer response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete a lecturer's record by staff number
    #
    # + return - No content 
    resource isolated function delete lecturers/[string staffNumber]() returns http:Response|error {
        string resourcePath = string `/lecturers/${getEncodedUri(staffNumber)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get all lecturers that teach a certain course
    #
    # + return - List of lecturers 
    resource isolated function get courses/[string courseCode]/lecturers() returns Lecturer[]|error {
        string resourcePath = string `/courses/${getEncodedUri(courseCode)}/lecturers`;
        Lecturer[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get all lecturers that sit in the same office
    #
    # + return - List of lecturers 
    resource isolated function get offices/[string officeNumber]/lecturers() returns Lecturer[]|error {
        string resourcePath = string `/offices/${getEncodedUri(officeNumber)}/lecturers`;
        Lecturer[] response = check self.clientEp->get(resourcePath);
        return response;
    }
}

public function main() returns error? {
    io:println("Client Starting Up !!");
    // http:Client lecturerClient = check new http:Client("http://localhost:9090");
    
    Client lecturerC = check new Client("localhost:9090");

    // Add a new lecturer
    Lecturer newLecturer = {
        staffNumber: "1069",
        officeNumber: "A2",
        staffName: "Jane Smith",
        title: "Associate Professor",
        courses: [{courseCode: "CS101"}, {courseCode: "DB101"}] // Specify the courses for the new lecturer
    };

    Lecturer updatedLecturer = {
        staffNumber: "1001",
        officeNumber: "A1",
        staffName: "From Front Side ",
        title: "Professor",
        courses: [{courseCode: "CS201"}, {courseCode: "WEB101"}] // Specify the updated courses
    };


    var addLecturerResponse = check lecturerC->/lecturers.post(newLecturer); ///post/lecturers; //newLecturer);
    io:println("Add Lecturer Response: ", addLecturerResponse);

    // Retrieve a list of all lecturers
    Lecturer[] getLecturersResponse = check lecturerC->/lecturers;// ->get("/lecturers");
    io:println("All Lecturers : ");
    foreach var lect in getLecturersResponse {
    io:println("Name :", lect.staffName, " Title :", lect.title );
    }

    // Update an existing lecturer's information 
    var updateLecturerResponse = check lecturerC->/lecturers/path.put(updatedLecturer); //->put("/lecturers/1001", updatedLecturer);
    io:println("Update Lecturer Response: ", updateLecturerResponse);

    // Retrieve the details of a specific lecturer by their staff number
    var getLecturerByStaffNumberResponse = check lecturerC->/lecturers/["1001"]; //get("/lecturers/1001");
    io:println("Get Lecturer By Staff Number Response: ", getLecturerByStaffNumberResponse);

    // Delete a lecturer's record by their staff number
    var deleteLecturerResponse = check lecturerC->/lecturers/["1002"].delete; //delete("/lecturers/1002");
    io:println("Delete Lecturer Response: ", deleteLecturerResponse);

    // Retrieve all the lecturers that teach a certain course
    var getLecturersByCourseResponse = check lecturerC->/courses/["WEB101"]/lecturers; //get("/courses/CS101/lecturers");
    io:println("Lecturers By Course (WEB101): ");
    foreach var lect in getLecturersByCourseResponse {
    io:println("Name :", lect.staffName, " Title :", lect.title );
    }

    // Retrieve all the lecturers that sit in the same office
    var getLecturersByOfficeResponse = check lecturerC->/offices/["A1"]/lecturers; // ->get("/offices/A1/lecturers");
    io:println("Lecturers By office (A1): ");
    foreach var lect in getLecturersByOfficeResponse {
    io:println("Name :", lect.staffName, " Title :", lect.title );
    }

    // Handle any errors that may occur
    // match addLecturerResponse, getLecturersResponse, updateLecturerResponse, getLecturerByStaffNumberResponse,
    //         deleteLecturerResponse, getLecturersByCourseResponse, getLecturersByOfficeResponse {
    //     http:Response | error addLecturerResp, http:Response | error getLecturersResp, 
    //     http:Response | error updateLecturerResp, http:Response | error getLecturerByStaffNumberResp,
    //     http:Response | error deleteLecturerResp, http:Response | error getLecturersByCourseResp,
    //     http:Response | error getLecturersByOfficeResp => {
    //         io:println("Error occurred: ", addLecturerResp, getLecturersResp, updateLecturerResp,
    //                     getLecturerByStaffNumberResp, deleteLecturerResp, getLecturersByCourseResp, 
    //                     getLecturersByOfficeResp);
    //     }
    // }
    
    // Close the HTTP client
    // check lecturerC stop();

    // Return an error if any of the requests fail
    error? err = error("");
    return err;
}


///////////////////

isolated function getEncodedUri(anydata value) returns string {
    string|error encoded = url:encode(value.toString(), "UTF8");
    if (encoded is string) {
        return encoded;
    } else {
        return value.toString();
    }
}
//////////////////
# Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.
@display {label: "Connection Config"}
public type ConnectionConfig record {|
    # The HTTP version understood by the client
    http:HttpVersion httpVersion = http:HTTP_2_0;
    # Configurations related to HTTP/1.x protocol
    ClientHttp1Settings http1Settings?;
    # Configurations related to HTTP/2 protocol
    http:ClientHttp2Settings http2Settings?;
    # The maximum time to wait (in seconds) for a response before closing the connection
    decimal timeout = 60;
    # The choice of setting `forwarded`/`x-forwarded` header
    string forwarded = "disable";
    # Configurations associated with request pooling
    http:PoolConfiguration poolConfig?;
    # HTTP caching related configurations
    http:CacheConfig cache?;
    # Specifies the way of handling compression (`accept-encoding`) header
    http:Compression compression = http:COMPRESSION_AUTO;
    # Configurations associated with the behaviour of the Circuit Breaker
    http:CircuitBreakerConfig circuitBreaker?;
    # Configurations associated with retrying
    http:RetryConfig retryConfig?;
    # Configurations associated with inbound response size limits
    http:ResponseLimitConfigs responseLimits?;
    # SSL/TLS-related options
    http:ClientSecureSocket secureSocket?;
    # Proxy server related options
    http:ProxyConfig proxy?;
    # Enables the inbound payload validation functionality which provided by the constraint package. Enabled by default
    boolean validation = true;
|};

# Provides settings related to HTTP/1.x protocol.
public type ClientHttp1Settings record {|
    # Specifies whether to reuse a connection for multiple requests
    http:KeepAlive keepAlive = http:KEEPALIVE_AUTO;
    # The chunking behaviour of the request
    http:Chunking chunking = http:CHUNKING_AUTO;
    # Proxy server related options
    ProxyConfig proxy?;
|};

# Proxy server configurations to be used with the HTTP client endpoint.
public type ProxyConfig record {|
    # Host name of the proxy server
    string host = "";
    # Proxy server port
    int port = 0;
    # Proxy server username
    string userName = "";
    # Proxy server password
    @display {label: "", kind: "password"}
    string password = "";
|};

public type LecturerArr Lecturer[];

public type Lecturer record {
    string staffNumber?;
    string officeNumber?;
    string staffName?;
    string title?;
    Course[] courses?;
};

public type Course record {
    string courseName?;
    string courseCode?;
    int nqfLevel?;
};